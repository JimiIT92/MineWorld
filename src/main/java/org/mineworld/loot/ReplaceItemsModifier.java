package org.mineworld.loot;

import com.google.common.base.Suppliers;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.storage.loot.LootContext;
import net.minecraft.world.level.storage.loot.LootTable;
import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
import net.minecraftforge.common.loot.IGlobalLootModifier;
import net.minecraftforge.common.loot.LootModifier;
import org.jetbrains.annotations.NotNull;
import org.mineworld.MineWorld;

import java.util.List;
import java.util.function.Supplier;

/**
 * {@link LootModifier Loot Modifier} for replacing some {@link MWLootReplaceEntry Items} to a {@link LootTable Loot Table}
 */
public final class ReplaceItemsModifier extends LootModifier {

    /**
     * The {@link MineWorld MineWorld} {@link ReplaceItemsModifier Replace Items Modifier} {@link Codec codec}
     */
    public static final Supplier<Codec<ReplaceItemsModifier>> CODEC = Suppliers.memoize(
            () -> RecordCodecBuilder.create(instance ->
                    codecStart(instance).and(
                            MWLootReplaceEntry.CODEC.listOf().fieldOf("entries").forGetter(modifier -> modifier.entries)
                    ).apply(instance, ReplaceItemsModifier::new)
            )
    );
    /**
     * {@link List<MWLootReplaceEntry> The list of items that can be replaced inside the loot}
     */
    private final List<MWLootReplaceEntry> entries;

    /**
     * Constructor. Set the {@link LootItemCondition Loot conditions} and the {@link List<MWLootReplaceEntry> Loot entries}
     *
     * @param lootConditions {@link LootItemCondition The ILootConditions that need to be matched before the loot is modified}
     * @param entries {@link List<MWLootReplaceEntry> The list of items that can be replaced inside the loot}
     */
    public ReplaceItemsModifier(final LootItemCondition[] lootConditions, final List<MWLootReplaceEntry> entries) {
        super(lootConditions);
        this.entries = entries;
    }

    /**
     * Add some {@link MWLootReplaceEntry items} to the loot
     *
     * @param generatedLoot {@link ObjectArrayList<ItemStack> The list of ItemStacks that will be dropped, generated by loot tables}
     * @param context {@link LootContext The LootContext, identical to what is passed to loot tables}
     * @return {@link ObjectArrayList<ItemStack> The updated loot}
     */
    @Override
    protected @NotNull ObjectArrayList<ItemStack> doApply(final ObjectArrayList<ItemStack> generatedLoot, final LootContext context) {
        this.entries.forEach(entry -> apply(entry, generatedLoot, context));
        return generatedLoot;
    }

    /**
     * Try to replace an {@link MWLootReplaceEntry item} into the loot
     *
     * @param entry {@link MWLootReplaceEntry The item to replace into the loot}
     * @param generatedLoot {@link ObjectArrayList<ItemStack> The list of ItemStacks that will be dropped, generated by loot tables}
     * @param context {@link LootContext The loot context}
     */
    private void apply(final MWLootReplaceEntry entry, final ObjectArrayList<ItemStack> generatedLoot, final LootContext context) {
        generatedLoot.stream().filter(item -> item.is(entry.original())).forEach(lootEntry -> {
            generatedLoot.remove(lootEntry);
            final ItemStack itemStack = entry.replacement().getDefaultInstance();
            entry.functions().ifPresent(functions -> functions.forEach(function -> function.apply(itemStack, context)));
            generatedLoot.add(itemStack);
        });
    }

    /**
     * Get the {@link Codec Loot Modifier Codec}
     *
     * @return {@link #CODEC The Loot Modifier Codec}
     */
    @Override
    public Codec<? extends IGlobalLootModifier> codec() {
        return CODEC.get();
    }

}